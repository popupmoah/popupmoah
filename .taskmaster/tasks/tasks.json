{
  "project": {
    "name": "팝업모아 (PopupMoah)",
    "version": "0.0.1-SNAPSHOT",
    "description": "실시간 팝업스토어, 샘플세일, 이벤트 정보 수집 및 공유 플랫폼"
  },
  "tags": {
    "master": {
      "name": "master",
      "description": "메인 개발 태스크",
      "created": "2024-12-19T00:00:00Z",
      "tasks": [
        {
          "id": 1,
          "title": "자동 크롤링 시스템 구현",
          "description": "정각마다 팝업스토어, 샘플세일, 이벤트 정보를 자동으로 수집하는 시스템 구축",
          "status": "pending",
          "priority": "high",
          "dependencies": [],
          "details": "Spring Scheduler와 WebClient/Jsoup을 활용한 웹 크롤링 시스템을 구현합니다. 수집된 데이터를 팝업스토어 엔티티에 매핑하고, 중복 데이터 처리 로직과 에러 핸들링을 포함합니다.",
          "testStrategy": "크롤링 스케줄러 동작 확인, 데이터 수집 및 저장 테스트, 에러 상황 처리 검증",
          "subtasks": []
        },
        {
          "id": 2,
          "title": "지도 API 연동",
          "description": "카카오맵/네이버맵 API를 활용한 지도 기반 탐색 기능 구현",
          "status": "pending",
          "priority": "high",
          "dependencies": [
            1
          ],
          "details": "카카오맵 또는 네이버맵 API를 연동하여 위치 기반 검색, 마커 표시, 상세 정보 표시 기능을 구현합니다. API 호출 제한과 비용을 고려한 캐싱 전략도 포함합니다.",
          "testStrategy": "지도 API 연동 테스트, 마커 표시 및 클릭 이벤트 검증, 캐싱 동작 확인",
          "subtasks": []
        },
        {
          "id": 3,
          "title": "고급 필터링 및 검색 시스템",
          "description": "날짜별, 브랜드별, 지역별, 예약 여부, 카테고리별 필터링 기능 구현",
          "status": "pending",
          "priority": "medium",
          "dependencies": [
            1
          ],
          "details": "JPA Specification을 활용한 동적 쿼리 생성으로 다양한 조건의 필터링을 지원합니다. 검색 성능 최적화를 위한 인덱싱과 페이징 처리도 포함합니다.",
          "testStrategy": "다양한 필터 조건 조합 테스트, 검색 성능 측정, 페이징 처리 검증",
          "subtasks": []
        },
        {
          "id": 4,
          "title": "예약 기능 연동",
          "description": "외부 예약 사이트 연결 및 대체 링크 제공 시스템 구현",
          "status": "pending",
          "priority": "medium",
          "dependencies": [
            1
          ],
          "details": "예약 가능한 경우 외부 예약 사이트로 연결하고, 예약 불가 시 브랜드 홈페이지, 인스타그램 등 대체 링크를 제공합니다. 링크 관리 시스템도 포함합니다.",
          "testStrategy": "예약 링크 연결 테스트, 대체 링크 제공 검증, 링크 관리 기능 확인",
          "subtasks": []
        },
        {
          "id": 5,
          "title": "사용자 방문 기록 관리",
          "description": "사용자별 팝업 방문 기록 및 공유 링크 생성 시스템 구현",
          "status": "pending",
          "priority": "medium",
          "dependencies": [
            1
          ],
          "details": "사용자별 방문 기록 엔티티를 생성하고, 기간별 방문 통계를 제공합니다. 공유 가능한 링크 생성 기능도 포함합니다.",
          "testStrategy": "방문 기록 CRUD 테스트, 통계 계산 검증, 공유 링크 생성 및 접근 테스트",
          "subtasks": []
        },
        {
          "id": 6,
          "title": "실시간 알림 시스템",
          "description": "새로운 팝업 정보 및 사용자 활동에 대한 실시간 알림 기능 구현",
          "status": "pending",
          "priority": "low",
          "dependencies": [
            1,
            5
          ],
          "details": "WebSocket 또는 Server-Sent Events를 활용하여 실시간 알림을 구현합니다. 사용자별 알림 설정과 푸시 알림도 포함합니다.",
          "testStrategy": "실시간 알림 전송 테스트, 사용자별 알림 설정 검증, 푸시 알림 동작 확인",
          "subtasks": []
        },
        {
          "id": 7,
          "title": "성능 최적화",
          "description": "데이터베이스 인덱싱, API 응답 캐싱, 이미지 최적화 등 성능 개선",
          "status": "pending",
          "priority": "low",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "데이터베이스 인덱싱, Redis 캐싱, 이미지 최적화, 페이징 처리 등을 통해 전반적인 성능을 개선합니다.",
          "testStrategy": "성능 테스트 실행, 응답 시간 측정, 캐싱 효과 검증",
          "subtasks": []
        },
        {
          "id": 8,
          "title": "보안 강화",
          "description": "API 보안, 데이터 보호, 파일 업로드 보안 등 보안 기능 강화",
          "status": "pending",
          "priority": "medium",
          "dependencies": [],
          "details": "API 보안, SQL Injection 방지, XSS 방지, 파일 업로드 보안 등을 강화합니다. JWT 토큰 관리도 개선합니다.",
          "testStrategy": "보안 취약점 스캔, 인증/인가 테스트, 파일 업로드 보안 검증",
          "subtasks": []
        },
        {
          "id": 9,
          "title": "모니터링 및 로깅 강화",
          "description": "애플리케이션 모니터링, 로깅, 에러 추적 시스템 강화",
          "status": "pending",
          "priority": "low",
          "dependencies": [
            1
          ],
          "details": "Prometheus 메트릭 수집, Grafana 대시보드 개선, 구조화된 로깅, 에러 추적 시스템을 강화합니다.",
          "testStrategy": "메트릭 수집 테스트, 대시보드 동작 확인, 로그 분석 검증",
          "subtasks": []
        },
        {
          "id": 10,
          "title": "API 문서화",
          "description": "RESTful API 문서화 및 개발자 가이드 작성",
          "status": "pending",
          "priority": "low",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "Swagger/OpenAPI를 활용한 API 문서화, 개발자 가이드, API 사용 예제를 작성합니다.",
          "testStrategy": "API 문서 정확성 검증, 예제 코드 테스트, 개발자 가이드 검토",
          "subtasks": []
        }
      ]
    }
  },
  "currentTag": "master",
  "lastUpdated": "2024-12-19T00:00:00Z",
  "popupmoah-main": {
    "tasks": [
      {
        "id": 1,
        "title": "Spring Boot 3.5.0 프로젝트 초기 설정 및 인프라 구축",
        "description": "Spring Boot 3.5.0 기반의 프로젝트를 초기화하고, Docker Compose 환경, 기본 보안, 모니터링 시스템을 구축합니다.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "- Spring Initializr(https://start.spring.io)에서 Java 17 이상, Gradle 또는 Maven, Spring Boot 3.5.0을 선택하고, Spring Web, Spring Security, Spring Data JPA, PostgreSQL, Redis, Actuator, micrometer-registry-prometheus 등 필수 스타터를 추가하여 프로젝트를 생성합니다.\n- 생성된 프로젝트를 Git 저장소에 초기 커밋합니다.\n- Dockerfile(Multi-stage build, JDK 17 이상 기반)로 Spring Boot 애플리케이션을 최적화하여 컨테이너화합니다.\n- .dockerignore 파일을 작성하여 Docker 빌드 최적화 및 불필요 파일 제외를 적용합니다.\n- docker-compose.yml 파일을 작성하여 애플리케이션, PostgreSQL 15, Redis 7, Prometheus, Grafana를 서비스로 정의합니다.\n- Prometheus의 scrape_configs를 Docker 환경에 맞게 타겟팅하도록 설정합니다.\n- application-docker.yml을 생성하여 Docker 환경 전용 설정(데이터베이스, Redis, 보안, Jasypt, 로그 등)을 분리 관리합니다.\n- Spring Security 및 JWT 기반 기본 보안 설정을 적용하고, actuator 엔드포인트 노출 및 보안 정책을 구성합니다.\n- Prometheus, Grafana 등 모니터링 도구를 Docker Compose에 통합하고, actuator metrics 엔드포인트를 Prometheus가 수집할 수 있도록 설정합니다.\n- README.md에 전체 인프라 구성, 실행 방법, 환경 변수, 주요 설정, 모니터링 대시보드 연동 방법을 문서화합니다.",
        "testStrategy": "- Docker Compose로 전체 인프라(애플리케이션, PostgreSQL, Redis, Prometheus, Grafana) 기동 및 정상 동작 확인\n- Spring Boot 애플리케이션에 JWT 기반 기본 보안이 적용되어 인증 없이 접근이 제한되는지 테스트\n- actuator 엔드포인트가 정상적으로 노출되고, Prometheus에서 metrics를 수집할 수 있는지 확인\n- Grafana에서 Prometheus 데이터를 시각화할 수 있는지 대시보드 연동 검증\n- README.md의 안내대로 신규 환경에서 전체 인프라를 재현할 수 있는지 검증",
        "subtasks": [
          {
            "id": 1,
            "title": "Dockerfile 생성 - Multi-stage build로 최적화된 컨테이너 이미지",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Docker Compose 설정 - PostgreSQL, Redis, Prometheus, Grafana 포함",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Prometheus 설정 업데이트 - Docker 환경에 맞게 타겟 설정",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "application-docker.yml 생성 - Docker 환경 전용 설정",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "README.md 문서화 - 전체 인프라 구성 및 실행 방법",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": ".dockerignore 생성 - Docker 빌드 최적화",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "데이터베이스 스키마 설계 및 JPA 엔티티 정의, 마이그레이션 설정",
        "description": "PostgreSQL 데이터베이스 스키마를 설계하고, JPA 엔티티를 정의하며, 데이터베이스 마이그레이션 도구를 설정합니다.",
        "details": "1. 요구사항에 따라 데이터베이스의 주요 테이블 구조(예: User, Post 등)를 설계합니다. ERD를 작성하여 엔티티 간 관계(1:N, N:M 등)를 명확히 정의합니다.\n2. Spring Boot 프로젝트에 spring-boot-starter-data-jpa, PostgreSQL JDBC 드라이버, 마이그레이션 도구(Flyway 또는 Liquibase) 의존성을 추가합니다.\n3. 각 테이블에 대응하는 JPA 엔티티 클래스를 생성하고, @Entity, @Table, @Id, @GeneratedValue, @Column 등 JPA 어노테이션을 활용해 필드와 제약조건을 명확히 지정합니다. (예: @Column(nullable = false, unique = true) 등)[1][2][4]\n4. 엔티티 간 연관관계 매핑(@OneToMany, @ManyToOne, @ManyToMany 등)을 설계에 맞게 구현합니다.\n5. Flyway 또는 Liquibase를 사용해 초기 스키마 생성 SQL 마이그레이션 파일을 작성하고, application.yml/properties에 데이터베이스 및 마이그레이션 설정을 추가합니다.\n6. 개발/운영 환경 분리를 고려해 데이터베이스 접속 정보와 마이그레이션 경로를 환경별로 분리 설정합니다.",
        "testStrategy": "1. Spring Boot 애플리케이션을 실행하여 JPA 엔티티가 정상적으로 테이블로 매핑되고, 마이그레이션이 자동 적용되어 데이터베이스에 테이블이 생성되는지 확인합니다.\n2. 엔티티 간 연관관계가 데이터베이스에 올바르게 반영되는지(외래키, 조인테이블 등) 확인합니다.\n3. Flyway/Liquibase 마이그레이션 로그를 통해 스키마가 정상적으로 적용되었는지 검증합니다.\n4. JPA Repository를 이용해 CRUD 테스트를 수행하여 엔티티 매핑 및 데이터베이스 연동이 정상적으로 동작하는지 확인합니다.\n5. 잘못된 엔티티 정의나 마이그레이션 오류 발생 시 예외 및 롤백이 정상적으로 동작하는지 테스트합니다.",
        "status": "in-progress",
        "dependencies": [
          1
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "팝업스토어 도메인 및 CRUD 서비스 레이어 구현",
        "description": "팝업스토어 엔티티, 저장소(Repository), 서비스 레이어를 구현하고, 기본 CRUD(생성, 조회, 수정, 삭제) 기능을 제공합니다.",
        "details": "1. Task 2에서 정의된 데이터베이스 스키마 및 JPA 엔티티 설계를 기반으로 PopupStore 엔티티 클래스를 생성합니다.\n2. PopupStore 엔티티에 필요한 필드(예: 이름, 위치, 시작일, 종료일 등)와 JPA 어노테이션(@Entity, @Id, @Column 등)을 적용합니다.\n3. JpaRepository<PopupStore, Long>를 상속하는 PopupStoreRepository 인터페이스를 생성합니다.\n4. PopupStoreRepository를 활용하는 PopupStoreService 클래스를 생성하고, CRUD 메서드(create, read, update, delete)를 구현합니다.\n5. 서비스 레이어에서 트랜잭션 처리(@Transactional) 및 예외 처리를 추가합니다.\n6. 향후 확장성을 고려해 서비스 계층의 메서드 시그니처와 구조를 설계합니다.\n7. (선택) 단위 테스트를 위한 테스트 더블(MockRepository 등) 설계도 고려합니다.",
        "testStrategy": "1. JPA Repository 및 서비스 레이어의 CRUD 메서드에 대한 단위 테스트를 작성합니다.\n2. 각 메서드가 정상적으로 동작하는지(엔티티 저장, 조회, 수정, 삭제) JUnit 및 Spring Boot Test를 활용해 검증합니다.\n3. 잘못된 입력값, 존재하지 않는 ID 등 예외 상황에 대한 테스트도 포함합니다.\n4. 테스트 데이터가 데이터베이스에 올바르게 반영되는지 확인합니다.\n5. 서비스 계층의 트랜잭션 및 예외 처리 동작을 검증합니다.",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "카테고리 관리 시스템 구현 (계층형 구조 지원)",
        "description": "카테고리 엔티티, 저장소(Repository), 서비스 계층을 구현하고, 계층적(트리형) 카테고리 구조를 지원하는 카테고리 관리 시스템을 개발합니다.",
        "details": "1. Task 2에서 정의된 데이터베이스 스키마 및 JPA 엔티티 설계를 기반으로 Category 엔티티 클래스를 생성합니다.\n2. Category 엔티티는 계층적 구조(부모-자식 관계)를 지원해야 하므로, self-referencing 관계(@ManyToOne, @OneToMany)를 설계합니다. 예: parent 필드와 children 컬렉션을 정의합니다.\n3. 카테고리의 주요 필드(이름, 설명, 정렬순서 등)와 JPA 어노테이션(@Entity, @Id, @Column, @ManyToOne, @OneToMany 등)을 적용합니다.\n4. JpaRepository<Category, Long>를 상속하는 CategoryRepository 인터페이스를 생성합니다.\n5. CategoryRepository를 활용하는 CategoryService 클래스를 생성하고, CRUD 메서드(create, read, update, delete) 및 계층형 카테고리 트리 조회 메서드를 구현합니다.\n6. 서비스 계층에서 트랜잭션 처리(@Transactional) 및 예외 처리를 추가합니다.\n7. 계층형 구조의 무한 깊이 지원을 위해 재귀적 조회 또는 계층형 쿼리(예: fetch join, @EntityGraph 등) 전략을 고려합니다.\n8. 향후 확장성을 고려해 서비스 계층의 메서드 시그니처와 구조를 설계합니다.\n9. (선택) 단위 테스트를 위한 테스트 더블(MockRepository 등) 설계도 고려합니다.",
        "testStrategy": "1. JPA Repository 및 서비스 레이어의 CRUD 메서드에 대한 단위 테스트를 작성합니다.\n2. 계층형 카테고리(부모-자식 관계) 생성, 조회, 수정, 삭제가 정상적으로 동작하는지 JUnit 및 Spring Boot Test를 활용해 검증합니다.\n3. 트리 구조의 카테고리 조회(전체 트리, 특정 하위 트리 등)가 올바르게 동작하는지 테스트합니다.\n4. 잘못된 입력값, 존재하지 않는 부모 ID 등 예외 상황에 대한 테스트도 포함합니다.\n5. 서비스 계층의 트랜잭션 및 예외 처리 동작을 검증합니다.\n6. 테스트 데이터가 데이터베이스에 올바르게 반영되는지 확인합니다.",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "S3 파일 업로드/다운로드 및 이미지 최적화 기능 구현",
        "description": "AWS S3와 연동하여 파일 업로드, 다운로드, 이미지 처리 및 최적화 기능을 구현합니다.",
        "details": "1. Spring Cloud AWS 또는 AWS SDK를 프로젝트에 의존성으로 추가합니다.\n2. S3 버킷 접근을 위한 IAM 권한 및 S3 버킷 정보를 application 설정에 등록합니다.\n3. 파일 업로드 기능: MultipartFile을 받아 AmazonS3PutRequest와 같은 DTO로 변환 후, S3Client 또는 AmazonS3 객체의 putObject 메서드를 활용해 S3에 업로드합니다. 업로드 시 파일명 중복 방지(타임스탬프, UUID 등) 및 디렉터리 구조(예: /images/yyyy-MM-dd/)를 적용합니다[1][4].\n4. 파일 다운로드 기능: S3에서 지정 key로 getObject를 호출하여 파일 스트림을 반환하고, 적절한 Content-Type 및 Content-Disposition 헤더를 설정해 클라이언트에 전달합니다.\n5. 이미지 처리 및 최적화: 업로드 전 썸네일 생성, 리사이즈, 포맷 변환(JPEG/WEBP 등) 등 이미지 최적화 로직을 적용합니다. 썸네일/원본을 구분해 S3에 저장하고, 처리 라이브러리(예: Thumbnailator, imgscalr 등)를 활용합니다.\n6. 업로드/다운로드/삭제/목록 조회 등 파일 관리 서비스 계층을 구현하고, 예외 및 오류 처리(파일 크기 제한, 확장자 검증 등)를 추가합니다.\n7. 테스트 및 운영 환경에서 S3 접근 권한, 네트워크, 파일 용량 등 보안 및 성능 이슈를 고려합니다.",
        "testStrategy": "1. 단위 테스트: 파일 업로드/다운로드/삭제/목록 조회 서비스 메서드에 대해 Mock S3 클라이언트를 활용한 단위 테스트를 작성합니다.\n2. 통합 테스트: 실제 S3 버킷에 파일을 업로드/다운로드/삭제하여 정상 동작을 검증합니다.\n3. 이미지 처리 테스트: 다양한 이미지(크기, 포맷) 업로드 시 썸네일 생성, 리사이즈, 포맷 변환이 정상적으로 동작하는지 확인합니다.\n4. 예외 상황 테스트: 허용되지 않은 확장자, 파일 크기 초과, 네트워크 오류 등 예외 상황에 대한 테스트를 포함합니다.\n5. 보안 테스트: S3 접근 권한, URL 노출, 파일명 충돌 등 보안 취약점이 없는지 검증합니다.",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "JWT 인증 시스템 구현 (Spring Security 기반)",
        "description": "Spring Security를 활용하여 JWT 기반 인증 시스템을 구축하고, JWT 토큰 생성/검증, 사용자 인증 및 권한 관리 기능을 구현합니다.",
        "details": "1. Spring Security 설정(SecurityConfig)에서 세션 기반 인증을 비활성화하고 JWT 인증 필터를 필터 체인에 등록합니다.\n2. JWTUtil 클래스를 생성하여 JWT 토큰의 생성, 서명, 파싱, 만료 검증, 클레임 추출 등의 기능을 구현합니다. 비밀키는 application.properties 또는 환경 변수로 안전하게 관리합니다.\n3. 로그인 요청 시 UsernamePasswordAuthenticationFilter를 커스텀하여 사용자의 인증 정보를 검증하고, 인증 성공 시 JWT 토큰을 발급해 응답 헤더(Authorization: Bearer <token>)에 포함시킵니다.\n4. JWT 인증 필터(JwtAuthenticationFilter)를 구현하여 모든 요청에서 Authorization 헤더의 JWT를 추출, 유효성 검증 후 SecurityContextHolder에 인증 정보를 저장합니다.\n5. 인증 및 인가(권한) 처리를 위해 UserDetailsService, UserDetails, GrantedAuthority를 구현하고, DB의 사용자 정보와 연동합니다.\n6. 인증이 필요한 엔드포인트와 공개 엔드포인트를 SecurityConfig에서 명확히 분리하여 설정합니다.\n7. JWT 토큰 만료, 위조, 미포함 등 예외 상황에 대한 처리 로직을 추가합니다.",
        "testStrategy": "1. Postman 등으로 로그인 API 호출 시 올바른 JWT 토큰이 발급되는지 확인합니다.\n2. JWT 토큰을 포함한 요청에 대해 인증이 필요한 엔드포인트 접근이 정상적으로 허용되는지, 토큰이 없거나 잘못된 경우 401 Unauthorized가 반환되는지 테스트합니다.\n3. JWT 만료, 위조, 권한 부족 등 다양한 예외 상황에 대한 응답을 검증합니다.\n4. 단위 테스트: JWTUtil의 토큰 생성/파싱/검증 메서드, 인증 필터의 동작, UserDetailsService의 사용자 정보 로딩에 대한 단위 테스트를 작성합니다.\n5. 통합 테스트: 실제 DB 사용자 정보와 연동하여 전체 인증/인가 플로우가 정상적으로 동작하는지 검증합니다.",
        "status": "pending",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "사용자 관리 시스템 구현 (엔티티, 회원가입/로그인, 프로필 관리)",
        "description": "사용자 엔티티를 설계하고, 회원가입 및 로그인 기능, 사용자 프로필 관리 기능을 구현합니다.",
        "details": "1. User 엔티티를 설계하여 username, password, email, 권한, 프로필 정보(닉네임, 프로필 이미지 등) 필드를 정의합니다. JPA 어노테이션을 활용해 데이터베이스와 매핑하고, 비밀번호는 BCrypt 등으로 암호화 저장합니다.\n2. 회원가입 API를 구현하여 사용자 입력값 검증, 중복 체크, 비밀번호 암호화, DB 저장 로직을 작성합니다.\n3. 로그인 API는 JWT 인증 시스템(Task 6)과 연동하여 UsernamePasswordAuthenticationFilter를 커스텀 구현하고, 인증 성공 시 JWT 토큰을 발급합니다.\n4. UserDetails, UserDetailsService를 구현하여 Spring Security 인증에 필요한 사용자 정보를 제공합니다. loadUserByUsername()에서 DB에서 사용자 정보를 조회하고, UserDetails를 반환하도록 합니다[1][2][4].\n5. 사용자 프로필 조회/수정 API를 구현하여, 인증된 사용자가 자신의 프로필 정보를 조회 및 수정할 수 있도록 합니다. 프로필 이미지 업로드 시 S3 연동(Task 5) 기능을 활용합니다.\n6. 예외 처리, 입력값 검증, 보안(비밀번호 정책, 인증/인가) 등 실무 수준의 검증 로직을 포함합니다.",
        "testStrategy": "1. 회원가입/로그인/프로필 API에 대해 단위 및 통합 테스트를 작성합니다.\n2. 정상 회원가입, 중복 가입, 잘못된 입력값, 비밀번호 암호화 여부를 검증합니다.\n3. 로그인 시 JWT 토큰이 정상 발급되고, 인증 실패(잘못된 비밀번호, 미존재 사용자 등) 시 적절한 에러가 반환되는지 확인합니다.\n4. 프로필 조회/수정 API가 인증된 사용자에 한해 정상 동작하는지, 프로필 이미지 업로드가 S3에 연동되는지 테스트합니다.\n5. UserDetailsService, User 엔티티, 인증 필터의 동작에 대한 단위 테스트를 작성합니다.\n6. 보안 취약점(비밀번호 평문 저장, 인증 우회 등)이 없는지 점검합니다.",
        "status": "pending",
        "dependencies": [
          2,
          6,
          5
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "팝업스토어 리뷰 시스템 구현 (엔티티, CRUD, 평점)",
        "description": "팝업스토어에 대한 리뷰 엔티티를 설계하고, 리뷰 작성/수정/삭제 및 평점 시스템을 포함한 리뷰 관리 기능을 구현합니다.",
        "details": "1. Review 엔티티를 설계하여 작성자(사용자), 대상 팝업스토어, 리뷰 내용, 평점(별점), 작성/수정일시 등의 필드를 정의하고, JPA 연관관계(@ManyToOne 등)를 설정합니다. 2. ReviewRepository(JpaRepository)를 생성하고, 리뷰 CRUD를 위한 ReviewService를 구현합니다. 3. 리뷰 작성, 수정, 삭제, 단일/목록 조회(페이징 포함) API를 REST 컨트롤러로 제공합니다. 4. 평점(별점) 필드는 1~5점 등으로 제한하고, 팝업스토어별 평균 평점 계산 로직을 서비스에 포함합니다. 5. 리뷰 작성/수정/삭제 시 인증된 사용자만 가능하도록 JWT 인증 및 사용자 정보 연동(Task 6, 7) 처리, 리뷰 작성 시 본인 확인 및 중복 작성 방지 로직을 추가합니다. 6. 리뷰 목록 조회 시 페이징, 정렬(최신순/평점순 등) 옵션을 지원합니다. 7. 예외 및 권한 처리, 트랜잭션 관리, API 응답 DTO 설계 등도 포함합니다.",
        "testStrategy": "1. 단위 테스트: ReviewService의 리뷰 생성, 수정, 삭제, 조회, 평균 평점 계산 메서드에 대한 테스트를 작성합니다. 2. 통합 테스트: 리뷰 API(작성/수정/삭제/조회)가 인증된 사용자에 한해 정상 동작하는지, 권한 없는 접근 시 적절한 에러가 반환되는지 검증합니다. 3. 리뷰 작성/수정/삭제 시 DB 반영 및 연관된 팝업스토어의 평균 평점이 올바르게 갱신되는지 확인합니다. 4. 페이징, 정렬, 예외 상황(중복 작성, 없는 리뷰 접근 등)에 대한 테스트를 포함합니다. 5. API 문서화(Swagger 등) 및 실제 클라이언트 연동 테스트도 수행합니다.",
        "status": "pending",
        "dependencies": [
          3,
          6,
          7
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "리뷰 댓글 및 답글 시스템 구현 (계층형 구조, CRUD)",
        "description": "팝업스토어 리뷰에 대한 댓글 및 답글(대댓글) 기능을 구현하고, 댓글의 작성/수정/삭제와 계층적(트리형) 구조를 지원합니다.",
        "details": "1. 리뷰(Comment) 엔티티를 설계하여 리뷰(Review)와 연관관계(@ManyToOne), 작성자(사용자), 부모 댓글(Parent), 내용, 작성/수정일시 등의 필드를 정의합니다. 계층형 구조를 위해 self-referencing(@ManyToOne, @OneToMany) 관계를 설정하고, 대댓글(답글)도 지원합니다.\n2. CommentRepository(JpaRepository)를 생성하고, 댓글 및 답글의 CRUD 메서드를 구현합니다. 페이징, 정렬(최신순 등), 특정 리뷰의 댓글 트리 조회 기능을 포함합니다.\n3. 댓글 서비스 계층(ReplyService/CommentService)과 구현체를 작성하여 댓글 등록, 수정, 삭제, 트리 조회, 권한 검증(본인/관리자만 수정·삭제) 로직을 포함합니다[1][2][3].\n4. 댓글 작성/수정/삭제 API를 REST 컨트롤러로 제공하며, JWT 인증(Task 6) 및 사용자 정보(Task 7)와 연동합니다.\n5. 예외 및 권한 처리, 트랜잭션 관리, API 응답 DTO 설계, 리뷰 삭제 시 연관 댓글 처리(연쇄 삭제 또는 soft delete) 등도 포함합니다.",
        "testStrategy": "1. 단위 테스트: CommentService의 댓글/답글 생성, 수정, 삭제, 트리 조회 메서드에 대한 테스트를 작성합니다.\n2. 통합 테스트: 댓글/답글 API(작성/수정/삭제/조회)가 인증된 사용자에 한해 정상 동작하는지, 권한 없는 접근 시 적절한 에러가 반환되는지 검증합니다.\n3. 계층형 구조(댓글-답글) 생성, 조회, 삭제 시 트리 구조가 올바르게 유지되는지 확인합니다.\n4. 리뷰 삭제 시 연관 댓글 처리(연쇄 삭제/soft delete) 동작을 테스트합니다.\n5. 페이징, 정렬, 예외 상황(없는 댓글 접근, 권한 없는 수정/삭제 등)에 대한 테스트를 포함합니다.\n6. API 문서화(Swagger 등) 및 실제 프론트엔드 연동 테스트를 수행합니다.",
        "status": "pending",
        "dependencies": [
          6,
          7,
          8
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "팝업스토어, 카테고리, 리뷰, 댓글 REST API 엔드포인트 및 컨트롤러 구현",
        "description": "팝업스토어, 카테고리, 리뷰, 댓글(답글 포함) 리소스에 대한 REST API 엔드포인트와 컨트롤러를 설계 및 구현합니다.",
        "details": "1. RESTful 원칙에 따라 각 리소스별 엔드포인트(URL)를 설계합니다. 예: /api/popup-stores, /api/categories, /api/reviews, /api/review-comments 등으로 구분합니다.\n2. 각 엔드포인트에 대해 GET(조회), POST(생성), PUT/PATCH(수정), DELETE(삭제) 메서드를 구현합니다. 쿼리 파라미터를 활용한 페이징, 정렬, 필터링 기능도 포함합니다.\n3. 팝업스토어, 카테고리, 리뷰, 댓글 각각의 컨트롤러 클래스를 생성하고, 서비스 계층과 연동하여 CRUD 및 트리 구조(카테고리, 댓글)에 맞는 응답을 반환합니다.\n4. JWT 인증(Task 6) 및 사용자 정보(Task 7)와 연동하여 인증/인가 처리를 적용합니다. 리뷰/댓글 작성·수정·삭제 시 권한 검증을 반드시 구현합니다.\n5. API 응답은 일관된 DTO로 반환하며, 예외 상황(권한 없음, 잘못된 요청 등)에 대한 표준화된 에러 응답을 제공합니다.\n6. Swagger(OpenAPI) 등으로 API 명세를 문서화합니다.\n7. 향후 확장성을 고려해 엔드포인트 및 컨트롤러 구조를 설계합니다.",
        "testStrategy": "1. 각 엔드포인트별로 단위 및 통합 테스트를 작성하여 CRUD, 계층형 조회, 페이징, 정렬, 필터링 기능이 정상 동작하는지 검증합니다.\n2. 인증이 필요한 엔드포인트에 대해 JWT 토큰이 없거나 잘못된 경우 401/403 에러가 반환되는지 테스트합니다.\n3. 권한 없는 사용자의 수정/삭제 요청, 잘못된 입력값, 존재하지 않는 리소스 접근 등 예외 상황에 대한 테스트를 포함합니다.\n4. Swagger 등 API 문서가 실제 구현과 일치하는지 검증합니다.\n5. 트리 구조(카테고리, 댓글) 조회 시 계층 구조가 올바르게 반환되는지 확인합니다.",
        "status": "pending",
        "dependencies": [
          3,
          4,
          6,
          7,
          8,
          9
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Redis 캐싱 시스템 구현 (연동, 전략 수립, 성능 최적화)",
        "description": "Spring Boot 애플리케이션에 Redis를 연동하고, 캐싱 전략을 수립하여 데이터 접근 성능을 최적화합니다.",
        "details": "1. spring-boot-starter-data-redis 의존성을 추가하고, application.yml/properties에 Redis 연결 정보를 설정합니다.\n2. @EnableCaching 어노테이션을 메인 클래스에 적용하여 Spring Cache 추상화와 연동합니다.\n3. RedisTemplate 및 CacheManager Bean을 구성하여 캐시 저장소로 Redis를 사용하도록 설정합니다.\n4. 캐싱 대상(예: 팝업스토어, 카테고리, 리뷰, 댓글 등)의 서비스 계층에 @Cacheable, @CacheEvict, @CachePut 어노테이션을 활용해 Cache-Aside 전략을 적용합니다. (예: 조회 시 캐시 우선, 변경 시 캐시 무효화)\n5. 캐시 키 설계(리소스별 prefix, 파라미터 조합), TTL(만료시간) 정책, 캐시 일관성(쓰기/삭제 시 무효화) 등 세부 전략을 수립합니다.\n6. 대용량 데이터/빈번한 변경이 발생하는 경우 캐시 적중률, 메모리 사용량, Redis 성능 모니터링 및 튜닝 방안을 마련합니다.\n7. 운영 환경에서 Redis 장애/네트워크 이슈 발생 시 graceful degradation(캐시 미스 fallback) 처리 로직을 구현합니다.\n8. 필요시 분산 락, 캐시 프리히트, 캐시 슬래시(동시 미스) 방지 등 고급 전략도 검토합니다.",
        "testStrategy": "1. Redis 서버가 정상적으로 연결되고, 캐시 데이터가 저장/조회/삭제되는지 단위 테스트 및 통합 테스트를 작성합니다.\n2. @Cacheable, @CacheEvict, @CachePut 적용 메서드에서 캐시 적중/미스 시 동작을 검증합니다.\n3. TTL 만료 후 데이터가 자동 삭제되는지, 데이터 변경 시 캐시가 올바르게 무효화되는지 확인합니다.\n4. 대량 트래픽/동시 요청 상황에서 캐시 적중률, 응답 속도, Redis 메모리 사용량을 모니터링합니다.\n5. Redis 장애/네트워크 단절 시 fallback(캐시 미스 시 DB 조회) 동작을 시뮬레이션하여 서비스 가용성을 검증합니다.\n6. 캐시 키 설계, 일관성, 성능 튜닝(파라미터 조정 등) 관련 테스트를 포함합니다.",
        "status": "pending",
        "dependencies": [
          1,
          6
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Prometheus 모니터링 시스템 구현 (메트릭 수집, 대시보드, 알림)",
        "description": "Spring Boot 애플리케이션의 메트릭을 Prometheus로 수집하고, Grafana 대시보드 구성 및 Alertmanager를 통한 알림 설정을 구현합니다.",
        "details": "1. spring-boot-actuator 및 micrometer-registry-prometheus 의존성을 추가하여 /actuator/prometheus 엔드포인트에서 메트릭을 노출합니다.\n2. prometheus.yml 파일의 scrape_configs에 Spring Boot 애플리케이션의 /actuator/prometheus 엔드포인트를 등록하고, job_name, metrics_path, scrape_interval(권장 10~60초) 등을 환경에 맞게 설정합니다[2][4].\n3. Prometheus 서버를 Docker Compose로 기동하고, 메트릭이 정상적으로 수집되는지 확인합니다.\n4. Grafana를 설치 및 연동하여 Prometheus를 데이터 소스로 등록하고, 주요 지표(트래픽, 에러율, 응답속도 등)에 대한 대시보드를 생성합니다.\n5. prometheus.yml의 alerting 및 rule_files를 활용해 임계치 기반 경고 규칙을 작성하고, Alertmanager와 연동하여 슬랙/이메일 등으로 알림을 전송합니다[2].\n6. 메트릭 타입(Counter, Gauge, Histogram, Summary)별로 커스텀 메트릭이 필요한 경우 micrometer API로 직접 등록합니다[1].\n7. 운영 환경에서는 scrape_interval, evaluation_interval, 알림 채널 등 성능 및 실시간성 요구에 맞게 조정합니다.",
        "testStrategy": "1. /actuator/prometheus 엔드포인트에서 메트릭이 정상적으로 노출되는지 curl 등으로 확인합니다.\n2. Prometheus UI에서 타임라인 그래프 및 쿼리(PromQL)로 메트릭이 수집되는지 검증합니다.\n3. Grafana 대시보드에서 주요 지표가 실시간으로 시각화되는지 확인합니다.\n4. 알림 규칙 조건을 인위적으로 유발(예: 에러율 증가)하여 Alertmanager를 통해 알림이 정상 발송되는지 테스트합니다.\n5. scrape_interval, evaluation_interval 등 설정 변경 시 메트릭 수집/알림 동작이 기대대로 반영되는지 검증합니다.",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "크롤링 시스템 구현 (외부 데이터 수집, 팝업스토어 정보 자동 업데이트, 스케줄링)",
        "description": "외부 웹사이트에서 팝업스토어 정보를 주기적으로 크롤링하여 데이터베이스에 자동으로 반영하는 크롤링 시스템을 구현합니다.",
        "details": "1. 크롤링 대상 외부 사이트의 구조(HTML, 데이터 위치, 접근 방식)를 분석합니다. 2. 정적 페이지의 경우 Jsoup 라이브러리를 활용하여 HTML을 파싱하고, 동적 페이지가 필요한 경우 Selenium WebDriver를 도입합니다[1][2][3][4]. 3. 크롤링 결과에서 팝업스토어 관련 정보(이름, 위치, 기간 등)를 추출하여 DTO로 매핑합니다. 4. 기존 팝업스토어 도메인 및 CRUD 서비스(Task 3)와 연동하여 신규 데이터는 생성, 기존 데이터는 업데이트(동일성 기준: 이름+기간 등)하는 로직을 구현합니다. 5. Spring Scheduler(@Scheduled) 또는 Quartz를 활용해 크롤링 및 데이터 갱신 작업을 주기적으로 실행합니다(예: 매일 1회). 6. 크롤링 실패/예외 상황(네트워크 오류, 구조 변경 등) 발생 시 로깅 및 알림(이메일, 슬랙 등) 기능을 추가합니다. 7. 크롤링 코드와 스케줄러는 별도 모듈/패키지로 분리하여 유지보수성을 높입니다. 8. 크롤링 빈도, 타임아웃, User-Agent 등은 설정 파일에서 관리할 수 있도록 구성합니다.",
        "testStrategy": "1. 크롤링 대상 사이트 구조 변경 시에도 정상적으로 데이터가 추출되는지 단위 테스트 및 통합 테스트를 작성합니다. 2. 스케줄러가 설정된 주기대로 동작하며, 데이터가 DB에 자동 반영되는지 확인합니다. 3. 신규/변경/삭제된 팝업스토어 정보가 올바르게 반영되는지 CRUD 서비스와 연동 테스트를 수행합니다. 4. 크롤링 실패, 네트워크 오류, 데이터 중복 등 예외 상황에 대한 테스트를 포함합니다. 5. 크롤링 결과 및 스케줄 실행 로그, 알림 기능이 정상 동작하는지 검증합니다.",
        "status": "pending",
        "dependencies": [
          3
        ],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "검색 및 필터링 기능 구현 (팝업스토어 검색, 카테고리별/고급 필터)",
        "description": "팝업스토어를 키워드, 카테고리, 기간, 위치 등 다양한 조건으로 검색하고, 카테고리별 및 고급 필터링 기능을 제공하는 검색 시스템을 구현합니다.",
        "details": "1. 팝업스토어, 카테고리 등 검색 대상 리소스의 엔티티 및 인덱싱 전략을 점검합니다.\n2. REST API 엔드포인트(/api/popup-stores/search 등)를 설계하고, 검색 키워드, 카테고리, 기간(진행중/예정/종료), 위치, 기타 고급 옵션(정렬, 페이징 등)을 쿼리 파라미터로 받도록 정의합니다.\n3. 서비스 계층에서 동적 쿼리(JPA Criteria, QueryDSL 등)를 활용해 복합 조건 검색 및 필터링 로직을 구현합니다.\n4. 카테고리별 필터링은 카테고리 ID/이름 기반으로, 고급 검색은 기간(날짜 범위), 위치(지역명/좌표), 상태(진행중/예정/종료), 키워드(이름/설명) 등 다양한 조건을 지원합니다.\n5. 검색 결과는 페이징, 정렬(최신순/인기순 등), 카테고리별 집계(카테고리별 결과 수)와 함께 반환합니다.\n6. 프론트엔드와 연동을 고려해 검색 결과 DTO, 필터 옵션 목록, 예외 처리(검색 결과 없음 등)도 표준화합니다.\n7. 성능 최적화를 위해 인덱스 추가, Redis 캐시(Task 11) 활용, 대용량 데이터 대응 전략을 마련합니다.",
        "testStrategy": "1. 다양한 검색 조건(키워드, 카테고리, 기간, 위치, 복합 조건)별로 단위 및 통합 테스트를 작성합니다.\n2. 페이징, 정렬, 카테고리별 필터, 고급 옵션이 정상 동작하는지 API 테스트를 수행합니다.\n3. 검색 결과가 DB와 일치하는지, 없는 조건에 대해 '검색 결과 없음' 메시지가 반환되는지 검증합니다.\n4. 대량 데이터 환경에서 성능(응답 속도, 캐시 적중률 등)을 측정하고, Redis 캐시 적용 시 캐시 적중/미스 동작을 테스트합니다.\n5. 엣지 케이스(잘못된 파라미터, 비정상 입력, 예외 상황) 및 보안(권한 없는 접근 차단) 테스트를 포함합니다.",
        "status": "pending",
        "dependencies": [
          3,
          4,
          10,
          11
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-03T06:22:51.314Z",
      "updated": "2025-08-03T07:24:38.334Z",
      "description": "PopupMoah 프로젝트의 메인 태스크 컨텍스트"
    }
  }
}